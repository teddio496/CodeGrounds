import { spawn } from 'child_process';
import { once } from 'events';

// some parts of execute functions are generated by CHAT-GPT
// CHAT GPT was used to convert the code into typescript code

async function execute_code_with_docker(
  language: string,
  code: string,
  input: string
): Promise<{ stderr: string, stdout: string; timeTaken: string; }> {
  const languageCommands: Record<string, string[]> = {
    Python: ["python3", "/code/temp.py"],
    JavaScript: ["node", "/code/temp.js"],
    Java: ["javac /code/Main.java && java -cp /code Main"],
    C: ["gcc /code/temp.c -o /code/temp && /code/temp"],
    "C++": ["g++ /code/temp.cpp -o /code/temp && /code/temp"],
    Ruby: ["ruby", "/code/temp.rb"],
    Go: ["go", "run /code/temp.go"],
    PHP: ["php", "/code/temp.php"],
    Bash: ["bash", "/code/temp.sh"],
    Rust: ["rustc /code/temp.rs -o /code/temp && /code/temp"],
    TypeScript: ["tsc temp.ts && node /code/temp.js"],
    Swift: ["swift", "/code/temp.swift"],
    Perl: ["perl", "/code/temp.pl"],
    Haskell: ["ghc temp.hs -o temp && /code/temp"],
  };

  const languageExtensions: Record<string, string> = {
    Python: "py",
    JavaScript: "js",
    C: "c",
    "C++": "cpp",
    Ruby: "rb",
    Go: "go",
    Java: "java",
    PHP: "php",
    Bash: "sh",
    Rust: "rs",
    TypeScript: "ts",
    Swift: "swift",
    Perl: "pl",
    Haskell: "hs",
  };

  if (!languageCommands[language]) {
    throw new Error(`Unsupported language: ${language}`);
  }

  const languageExtension = languageExtensions[language];
  if (!languageExtension) {
    throw new Error(`Unsupported file extension for language: ${language}`);
  }

  try {
    if (language === "Bash") {
      code = code.replace(/\r\n/g, "\n");
    }

    let filename = language === "Java" ? "Main" : "temp";

    const startTime = Date.now();

    const child = spawn("sudo", [
      "docker",
      "run", // run container
      "--rm", // remove container once finished
      "-i", // allow interactive input (for stdin)
      "--memory=512m",
      "--pids-limit=20",
      "exec-multi", // image name
      "bash", // launch bash inside container environment
      "-c", // about to give the command
      `
        echo "${code.replace(/"/g, '\\"')}" > /code/${filename}.${languageExtension} &&
        ${languageCommands[language].join(" ")}
      ` // actual command to run  
    ]);

    if (input) {
      child.stdin.write(`${input}`);
      child.stdin.end();
    }

    let output = "";
    let errorOutput = "";
    let lineCount = 0;

    // restrict output to 100 lines (show at most 100 lines if inf loop executed)
    child.stdout.on("data", (data) => {
      const lines = data.toString().split("\n");
      for (const line of lines) {
        if (lineCount < 100) {
          output += line + "\n";
          lineCount++;
        } else {
          break;
        }
      }
    });

    child.stderr.on("data", (data) => {
      errorOutput += data.toString();
    });

    let time = 5250;

    const timeout = setTimeout(() => {
      child.kill("SIGKILL");
      killAllDockerContainers();
      errorOutput += "Execution exceeded time limit.\n";
      console.log("Process timed out and was killed.");
    }, time);

    await once(child, "close");

    clearTimeout(timeout);
    const endTime = Date.now();
    const timeTaken = endTime - startTime; // in milliseconds

    // Convert the time to a more readable format
    const seconds = (timeTaken / 1000).toFixed(4);

    console.log("reached");

    console.log({ stderr: errorOutput, stdout: output, timeTaken: `\n[Took ${seconds} seconds]` });

    return { stderr: errorOutput, stdout: output, timeTaken: `\n[Took ${seconds} seconds]` };
  } catch (error) {
    console.error("Error:", error);
    throw error;
  }
}

function killAllDockerContainers() {
  // First, spawn the "docker ps -q" command to get all running container IDs
  const ps = spawn("sudo", ["docker", "ps", "-q"]);

  let containerIds = "";

  // Capture the output of the "docker ps -q" command (container IDs)
  ps.stdout.on("data", (data) => {
    containerIds += data.toString();
  });

  // Handle any errors from "docker ps -q"
  ps.stderr.on("data", (data) => {
    console.error(`stderr: ${data}`);
  });

  // Once "docker ps -q" finishes, use the container IDs in the "docker kill" command
  ps.on("close", (code) => {
    if (code === 0) {
      // Now spawn the "docker kill" command with the container IDs
      const kill = spawn("sudo", ["docker", "kill", ...containerIds.split("\n").filter(id => id !== "")]);

      kill.stdout.on("data", (data) => {
        console.log(`stdout: ${data}`);
      });

      kill.stderr.on("data", (data) => {
        console.error(`stderr: ${data}`);
      });

      kill.on("close", (killCode) => {
        if (killCode === 0) {
          console.log("All containers have been killed.");
        } else {
          console.error("Failed to kill containers.");
        }
      });
    } else {
      console.error("Failed to get running container IDs.");
    }
  });
}

interface PostRequestBody {
  code: string;
  input: string;
  language: string;
}

export async function POST(req: Request): Promise<Response> {
  const { code, input, language }: PostRequestBody = await req.json();

  try {
    const result = await execute_code_with_docker(language, code, input);
    return new Response(JSON.stringify({ output: result }), { status: 200 });
  } catch (error) {
    return new Response(JSON.stringify({ message: "Error during code execution" }), { status: 400 });
  }
}
