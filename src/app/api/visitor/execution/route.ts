import { spawn } from 'child_process';
import fs from 'fs';
import path from 'path';
import { once } from 'events';

// some parts of execute functions are generated by CHAT-GPT
// CHAT GPT was used to convert the code into typescript code

async function execute_python(code: string, input: string): Promise<string> {
    const temp_python_file = path.join(__dirname, 'temp.py');
    const input_file = path.join(__dirname, 'input.txt');
    try {
        await fs.promises.writeFile(temp_python_file, code);
        await fs.promises.writeFile(input_file, input);
        const child = spawn('python3', [temp_python_file], { stdio: ['pipe', 'pipe', 'pipe'] });
        fs.createReadStream(input_file).pipe(child.stdin);

        let output = '';
        let errorOutput = '';
        child.stdout.on('data', (data) => { output += data.toString(); });
        child.stderr.on('data', (data) => { errorOutput += data.toString(); });
        
        await once(child, 'close');
        return errorOutput || output || "No output from Python Code";
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

async function execute_c(code: string, input: string): Promise<string> {
    const temp_c_file = path.join(__dirname, 'temp.c');
    const input_file = path.join(__dirname, 'input.txt');
    const compiled_file = path.join(__dirname, 'main');

    try {
        await fs.promises.writeFile(temp_c_file, code);
        await fs.promises.writeFile(input_file, input);

        const compileChild = spawn('gcc', [temp_c_file, '-o', compiled_file]);
        let compileErrorOutput = '';
        compileChild.stderr.on('data', (data) => { compileErrorOutput += data.toString(); });
        const exitCode = await new Promise<number>((resolve) => {
            compileChild.on('close', (code: any) => { resolve(code); });
        });

        if (exitCode !== 0) return `Compile Error: ${compileErrorOutput.trim()}`;

        const execChild = spawn(`${compiled_file}`, { stdio: ['pipe', 'pipe', 'pipe'] });
        fs.createReadStream(input_file).pipe(execChild.stdin);

        let output = '';
        let errorOutput = '';
        execChild.stdout.on('data', (data) => { output += data.toString(); });
        execChild.stderr.on('data', (data) => { errorOutput += data.toString(); });
        
        await once(execChild, 'close');
        return errorOutput || output || "No output from C program.";
        
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

async function execute_cpp(code: string, input: string): Promise<string> {
    const temp_cpp_file = path.join(__dirname, 'temp.cpp');
    const input_file = path.join(__dirname, 'input.txt');
    const compiled_file = path.join(__dirname, 'main_cpp');

    try {
        await fs.promises.writeFile(temp_cpp_file, code);
        await fs.promises.writeFile(input_file, input);

        const compileChild = spawn('g++', [temp_cpp_file, '-o', compiled_file]);
        let compileErrorOutput = '';
        compileChild.stderr.on('data', (data) => { compileErrorOutput += data.toString(); });
         const exitCode = await new Promise<number>((resolve) => {
            compileChild.on('close', (code: any) => { resolve(code); });
        });

        if (exitCode !== 0) return `Compile Error: ${compileErrorOutput.trim()}`;

        const execChild = spawn(`${compiled_file}`, { stdio: ['pipe', 'pipe', 'pipe'] });
        fs.createReadStream(input_file).pipe(execChild.stdin);

        let output = '';
        let errorOutput = '';
        execChild.stdout.on('data', (data) => { output += data.toString(); });
        execChild.stderr.on('data', (data) => { errorOutput += data.toString(); });
        
        await once(execChild, 'close');
        return errorOutput || output || "No output from C++ program.";
        
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

async function execute_java(code: string, input: string): Promise<string> {
    const temp_java_file = path.join(__dirname, 'Temp.java');
    const input_file = path.join(__dirname, 'input.txt');

    try {
        await fs.promises.writeFile(temp_java_file, code);
        await fs.promises.writeFile(input_file, input);

        const compileChild = spawn('javac', [temp_java_file]);
        let compileErrorOutput = '';
        compileChild.stderr.on('data', (data) => { compileErrorOutput += data.toString(); });
        
        const exitCode = await new Promise<number>((resolve) => {
            compileChild.on('close', (code: any) => { resolve(code); });
        });

        if (exitCode !== 0) return `Compile Error: ${compileErrorOutput.trim()}`;

        const execChild = spawn('java', ['-cp', __dirname, 'Temp'], { stdio: ['pipe', 'pipe', 'pipe'] });
        fs.createReadStream(input_file).pipe(execChild.stdin);

        let output = '';
        let errorOutput = '';
        execChild.stdout.on('data', (data) => { output += data.toString(); });
        execChild.stderr.on('data', (data) => { errorOutput += data.toString(); });
        
        await once(execChild, 'close');
        return errorOutput || output || "No output from Java program.";
        
    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

async function execute_js(code: string, input: string): Promise<string> {
    const temp_js_file = path.join(__dirname, 'temp.js');
    const input_file = path.join(__dirname, 'input.txt');

    try {
        await fs.promises.writeFile(temp_js_file, code);
        await fs.promises.writeFile(input_file, input);

        const child = spawn('node', [temp_js_file], { stdio: ['pipe', 'pipe', 'pipe'] });
        fs.createReadStream(input_file).pipe(child.stdin);

        let output = '';
        let errorOutput = '';

        child.stdout.on('data', (data) => { output += data.toString(); });
        child.stderr.on('data', (data) => { errorOutput += data.toString(); });

        await once(child, 'close');

        return errorOutput || output || "No output from JavaScript program.";

    } catch (error) {
        console.error('Error:', error);
        throw error;
    }
}

type ExecuteFunction = (code: string, input: string) => Promise<string>;

interface PostRequestBody {
    code: string;
    input: string;
    language: string;
}

export async function POST(req: Request): Promise<Response> {
    const { code, input, language }: PostRequestBody = await req.json();

    const executors: { [key: string]: ExecuteFunction } = {
        'Python': execute_python,
        'C': execute_c,
        'C++': execute_cpp,
        'Java': execute_java,
        'JavaScript': execute_js
    };

    const execute = executors[language];
    if (!execute) {
        return new Response(JSON.stringify({ message: "Not a supported language", status: 400 }), { status: 400 });
    }

    try {
        const result = await execute(code, input);
        return new Response(JSON.stringify({ output: result }), { status: 200 });
    } catch (error) {
        return new Response(JSON.stringify({ message: "Error during code execution", status: 500 }), { status: 500 });
    }
}
